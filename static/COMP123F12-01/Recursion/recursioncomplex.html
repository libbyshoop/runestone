


<!DOCTYPE html>



<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Complex Recursive Problems &mdash; How to Think like a Computer Scientist: Interactive Edition</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/video.css" type="text/css" />
    <link rel="stylesheet" href="../_static/edu-python.css" type="text/css" />
    <link rel="stylesheet" href="../_static/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="../_static/theme/default.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/simplemodal.js"></script>
    <script type="text/javascript" src="../_static/jquery.textarea.js"></script>
    <script type="text/javascript" src="../_static/edu-python.js"></script>
    <script type="text/javascript" src="../_static/bookfuncs.js"></script>
    <script type="text/javascript" src="../_static/codemirror.js"></script>
    <script type="text/javascript" src="../_static/python.js"></script>
    <script type="text/javascript" src="../_static/skulpt.js"></script>
    <script type="text/javascript" src="../_static/builtin.js"></script>
    <script type="text/javascript" src="../_static/assess.js"></script>
    <script type="text/javascript" src="../_static/animationbase.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="How to Think like a Computer Scientist: Interactive Edition" href="../index.html" />
<script type="text/javascript"> 
eBookConfig = {}
eBookConfig.host = 'http://141.140.167.226:8000' ? 'http://141.140.167.226:8000' : 'http://127.0.0.1:8000',
eBookConfig.app = eBookConfig.host+'/courselib',
eBookConfig.ajaxURL = eBookConfig.app+'/ajax/',
eBookConfig.course = 'COMP123F12-01',
eBookConfig.logLevel = 10,
eBookConfig.loginRequired = true
</script>

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">How to Think Like a Computer Scientist</a> &raquo;</li>
<li class="right"><span class="loginout"><a href="/courselib/default/user/logout">logout</a></span>| </li>

      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.jpg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Complex Recursive Problems</a><ul>
<li><a class="reference internal" href="#tower-of-hanoi">Tower of Hanoi</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exploring-a-maze">Exploring a Maze</a></li>
<li><a class="reference internal" href="#dynamic-programming">Dynamic Programming</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/Recursion/recursioncomplex.txt"
           rel="nofollow">Show Source</a></li>
  </ul><!--<div id="runestonebox">
  <h3>Runestone Links</h3>
  <ul>
    <li>
      <a href="https://github.com/bnmnetp/runestone/issues/new">Report a Problem</a>
    </li>
    <li>
      <a href="http://runestoneinteractive.org">About Runestone</a>
    </li>
    <li>
      <a href="/courselib/admin/index">Instructors Page</a>
    </li>
  </ul>
</div>
-->
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="complex-recursive-problems">
<h1>Complex Recursive Problems<a class="headerlink" href="#complex-recursive-problems" title="Permalink to this headline">¶</a></h1>
<p>In the previous sections we looked at some problems that are relatively
easy to solve, and some graphically interesting problems that can help
us gain a mental model of what is happening in a recursive algorithm. In
this section we will look at some problems that are really difficult to
solve using an iterative programming style but are very elegant and easy
to solve using recursion. We will finish up by looking at a deceptive
problem that at first looks like it has an elegant recursive solution
but in fact does not.</p>
<div class="section" id="tower-of-hanoi">
<h2>Tower of Hanoi<a class="headerlink" href="#tower-of-hanoi" title="Permalink to this headline">¶</a></h2>
<p>The Tower of Hanoi puzzle was invented by the French mathematician
Edouard Lucas in 1883. He was inspired by a legend that tells of a Hindu
temple where the puzzle was presented to young priests. At the beginning
of time, the priests were given three poles and a stack of 64 gold
disks, each disk a little smaller than the one beneath it. Their
assignment was to transfer all 64 disks from one of the three poles to
another, with two important constraints. They could only move one disk
at a time, and they could never place a larger disk on top of a smaller
one. The priests worked very efficiently, day and night, moving one disk
every second. When they finished their work, the legend said, the temple
would crumble into dust and the world would vanish.</p>
<p>Although the legend is interesting, you need not worry about the world
ending any time soon. The number of moves required to correctly move a
tower of 64 disks is <span class="math">\(2^{64}-1 = 18,446,744,073,709,551,615\)</span>. At
a rate of one move per second, that is <span class="math">\(584,942,417,355\)</span> years! Clearly
there is more to this puzzle than meets the eye.</p>
<p><a class="reference internal" href="#fig-hanoi"><em>Figure 1</em></a> shows an example of a configuration of disks in the
middle of a move from the first peg to the third. Notice that, as the
rules specify, the disks on each peg are stacked so that smaller disks
are always on top of the larger disks. If you have not tried to solve
this puzzle before, you should try it now. You do not need fancy disks
and poles–a pile of books or pieces of paper will work.</p>
<div class="figure align-center" id="fig-hanoi">
<img alt="image" src="../_images/hanoi.png" />
<p class="caption">An Example Arrangement of Disks for the Tower of Hanoi</p>
</div>
<p>How do we go about solving this problem recursively? How would you go
about solving this problem at all? What is our base case? Let’s think
about this problem from the bottom up. Suppose you have a tower of five
disks, originally on peg one. If you already knew how to move a tower of
four disks to peg two, you could then easily move the bottom disk to peg
three, and then move the tower of four from peg two to peg three. But
what if you do not know how to move a tower of height four? Suppose that
you knew how to move a tower of height three to peg three; then it would
be easy to move the fourth disk to peg two and move the three from peg
three on top of it. But what if you do not know how to move a tower of
three? How about moving a tower of two disks to peg two and then moving
the third disk to peg three, and then moving the tower of height two on
top of it? But what if you still do not know how to do this? Surely you
would agree that moving a single disk to peg three is easy enough,
trivial you might even say. This sounds like a base case in the making.</p>
<p>Here is a high-level outline of how to move a tower from the starting
pole, to the goal pole, using an intermediate pole:</p>
<ol class="arabic simple">
<li>Move a tower of height-1 to an intermediate pole, using the final
pole.</li>
<li>Move the remaining disk to the final pole.</li>
<li>Move the tower of height-1 from the intermediate pole to the final
pole using the original pole.</li>
</ol>
<p>As long as we always obey the rule that the larger disks remain on the
bottom of the stack, we can use the three steps above recursively,
treating any larger disks as though they were not even there. The only
thing missing from the outline above is the identification of a base
case. The simplest Tower of Hanoi problem is a tower of one disk. In
this case, we need move only a single disk to its final destination. A
tower of one disk will be our base case. In addition, the steps outlined
above move us toward the base case by reducing the height of the tower
in steps 1 and 3. <a class="reference internal" href="#lst-hanoi"><em>Listing 1</em></a> shows the Python code to solve the
Tower of Hanoi puzzle.</p>
<div class="highlight-python" id="lst-hanoi"><div class="highlight"><pre><span class="k">def</span> <span class="nf">moveTower</span><span class="p">(</span><span class="n">height</span><span class="p">,</span><span class="n">fromPole</span><span class="p">,</span> <span class="n">toPole</span><span class="p">,</span> <span class="n">withPole</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">moveTower</span><span class="p">(</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">fromPole</span><span class="p">,</span><span class="n">withPole</span><span class="p">,</span><span class="n">toPole</span><span class="p">)</span>
        <span class="n">moveDisk</span><span class="p">(</span><span class="n">fromPole</span><span class="p">,</span><span class="n">toPole</span><span class="p">)</span>
        <span class="n">moveTower</span><span class="p">(</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">withPole</span><span class="p">,</span><span class="n">toPole</span><span class="p">,</span><span class="n">fromPole</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the code in <a class="reference internal" href="#lst-hanoi"><em>Listing 1</em></a> is almost identical to the
English description. The key to the simplicity of the algorithm is that
we make two different recursive calls, one on line 3 and a
second on line 5. On line 3 we move all but the bottom
disk on the initial tower to an intermediate pole. The next line simply
moves the bottom disk to its final resting place. Then on line
5 we move the tower from the intermediate pole to the top of
the largest disk. The base case is detected when the tower height is 0;
in this case there is nothing to do, so the <tt class="docutils literal"><span class="pre">moveTower</span></tt> function
simply returns. The important thing to remember about handling the base
case this way is that simply returning from <tt class="docutils literal"><span class="pre">moveTower</span></tt> is what
finally allows the <tt class="docutils literal"><span class="pre">moveDisk</span></tt> function to be called.</p>
<p>The function <tt class="docutils literal"><span class="pre">moveDisk</span></tt>, shown in <a class="reference internal" href="#lst-movedisk"><em>Listing 2</em></a>, is very
simple. All it does is print out that it is moving a disk from one pole
to another. If you type in and run the <tt class="docutils literal"><span class="pre">moveTower</span></tt> program you can see
that it gives you a very efficient solution to the puzzle.</p>
<div class="highlight-python" id="lst-movedisk"><div class="highlight"><pre><span class="k">def</span> <span class="nf">moveDisk</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="n">tp</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;moving disk from&quot;</span><span class="p">,</span><span class="n">fp</span><span class="p">,</span><span class="s">&quot;to&quot;</span><span class="p">,</span><span class="n">tp</span><span class="p">)</span>
</pre></div>
</div>
<p>The following activecode program provides the entire solution for three disks.</p>

<div id="hanoi" >
<textarea cols="50" rows="12" id="hanoi_code" class="active_code">
def moveTower(height,fromPole, toPole, withPole):
    if height >= 1:
        moveTower(height-1,fromPole,withPole,toPole)
        moveDisk(fromPole,toPole)
        moveTower(height-1,withPole,toPole,fromPole)

def moveDisk(fp,tp):
    print("moving disk from",fp,"to",tp)

moveTower(3,"A","B","C")

</textarea>
<p class="ac_caption"><span class="ac_caption_text"> (hanoi)</span> </p>
<button onclick="runit('hanoi',this, undefined);">Run</button>
<button class="ac_opt" onclick="saveEditor('hanoi');">Save</button>
<button class="ac_opt" onclick="requestCode('hanoi');">Load</button>
<br />

<canvas id="hanoi_canvas" height="400" width="400" style="border-style: solid; display: none"></canvas>

<pre id="hanoi_pre" class="active_out">

</pre>

</div>

<p>Now that you have seen the code for both <tt class="docutils literal"><span class="pre">moveTower</span></tt> and <tt class="docutils literal"><span class="pre">moveDisk</span></tt>,
you may be wondering why we do not have a data structure that explicitly
keeps track of what disks are on what poles. Here is a hint: if you were
going to explicitly keep track of the disks, you would probably use
three <tt class="docutils literal"><span class="pre">Stack</span></tt> objects, one for each pole. The answer is that Python
provides the stacks that we need implicitly through the call stack, just
like it did in the <tt class="docutils literal"><span class="pre">toStr</span></tt> problem.</p>
</div>
</div>
<div class="section" id="exploring-a-maze">
<h1>Exploring a Maze<a class="headerlink" href="#exploring-a-maze" title="Permalink to this headline">¶</a></h1>
<p>In this section we will look at a problem that has relevance to the
expanding world of robotics, finding your way out of a maze. If you have
a Roomba vacuum cleaner for your dorm room (don’t all college students?)
you will wish that you could reprogram it using what you have learned in
this section. The problem we want to solve is to help our turtle find
its way out of a virtual maze. The maze problem has roots as deep as the
Greek myth about Theseus who was sent into a maze to kill the minotaur.
Theseus used a ball of thread to help him find his way back out again
once he had finished off the beast. In our problem we will assume that
our turtle is dropped down somewhere into the middle of the maze and
must find its way out. Look at <a class="reference internal" href="#fig-mazescreen"><em>Figure 3</em></a> to get an idea of
where we are going in this section.</p>
<div class="figure align-center" id="fig-mazescreen">
<img alt="../_images/maze.png" src="../_images/maze.png" />
<p class="caption">The Finished Maze Search Program</p>
</div>
<p>To make it easier for us we will assume that our maze is divided up into
“squares.” Each square of the maze is either open or occupied by a
section of wall. The turtle can only pass through the open squares of
the maze. If the turtle bumps into a wall it must try a different
direction. The turtle will require a systematic procedure to find its
way out of the maze. Here is the procedure:</p>
<ul class="simple">
<li>From our starting position we will first try going North one square
and then recursively try our procedure from there.</li>
<li>If we are not successful by trying a Northern path as the first step
then we will take a step to the South and recursively repeat our
procedure.</li>
<li>If South does not work then we will try a step to the West as our
first step and recursively apply our procedure.</li>
<li>If North, South, and West have not been successful then apply the
procedure recursively from a position one step to our East.</li>
<li>If none of these directions works then there is no way to get out of
the maze and we fail.</li>
</ul>
<p>Now, that sounds pretty easy, but there are a couple of details to talk
about first. Suppose we take our first recursive step by going North. By
following our procedure our next step would also be to the North. But if
the North is blocked by a wall we must look at the next step of the
procedure and try going to the South. Unfortunately that step to the
south brings us right back to our original starting place. If we apply
the recursive procedure from there we will just go back one step to the
North and be in an infinite loop. So, we must have a strategy to
remember where we have been. In this case we will assume that we have a
bag of bread crumbs we can drop along our way. If we take a step in a
certain direction and find that there is a bread crumb already on that
square, we know that we should immediately back up and try the next
direction in our procedure. As we will see when we look at the code for
this algorithm, backing up is as simple as returning from a recursive
function call.</p>
<p>As we do for all recursive algorithms let us review the base cases. Some
of them you may already have guessed based on the description in the
previous paragraph. In this algorithm, there are four base cases to
consider:</p>
<ol class="arabic simple">
<li>The turtle has run into a wall. Since the square is occupied by a
wall no further exploration can take place.</li>
<li>The turtle has found a square that has already been explored. We do
not want to continue exploring from this position or we will get into
a loop.</li>
<li>We have found an outside edge, not occupied by a wall. In other words
we have found an exit from the maze.</li>
<li>We have explored a square unsuccessfully in all four directions.</li>
</ol>
<p>For our program to work we will need to have a way to represent the
maze. To make this even more interesting we are going to use the turtle
module to draw and explore our maze so we can watch this algorithm in
action. The maze object will provide the following methods for us to use
in writing our search algorithm:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">__init__</span></tt> Reads in a data file representing a maze, initializes
the internal representation of the maze, and finds the starting
position for the turtle.</li>
<li><tt class="docutils literal"><span class="pre">drawMaze</span></tt> Draws the maze in a window on the screen.</li>
<li><tt class="docutils literal"><span class="pre">updatePosition</span></tt> Updates the internal representation of the maze
and changes the position of the turtle in the window.</li>
<li><tt class="docutils literal"><span class="pre">isExit</span></tt> Checks to see if the current position is an exit from the
maze.</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">Maze</span></tt> class also overloads the index operator <tt class="docutils literal"><span class="pre">[]</span></tt> so that our
algorithm can easily access the status of any particular square.</p>
<p>Let’s examine the code for the search function which we call
<tt class="docutils literal"><span class="pre">searchFrom</span></tt>. The code is shown in <a class="reference internal" href="#lst-mazesearch"><em>Listing 3</em></a>. Notice
that this function takes three parameters: a maze object, the starting
row, and the starting column. This is important because as a recursive
function the search logically starts again with each recursive call.</p>
<div class="highlight-python" id="lst-mazesearch"><pre>def searchFrom(maze, startRow, startColumn):
    maze.updatePosition(startRow, startColumn)
   #  Check for base cases:
   #  1. We have run into an obstacle, return false
   if maze[startRow][startColumn] == OBSTACLE :
        return False
    #  2. We have found a square that has already been explored
    if maze[startRow][startColumn] == TRIED:
        return False
    # 3. Success, an outside edge not occupied by an obstacle
    if maze.isExit(startRow,startColumn):
        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
        return True
    maze.updatePosition(startRow, startColumn, TRIED)

    # Otherwise, use logical short circuiting to try each
    # direction in turn (if needed)
    found = searchFrom(maze, startRow-1, startColumn) or \
            searchFrom(maze, startRow+1, startColumn) or \
            searchFrom(maze, startRow, startColumn-1) or \
            searchFrom(maze, startRow, startColumn+1)
    if found:
        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
    else:
        maze.updatePosition(startRow, startColumn, DEAD_END)
    return found</pre>
</div>
<p>As you look through the algorithm you will see that the first thing the
code does (line 2) is call <tt class="docutils literal"><span class="pre">updatePosition</span></tt>. This is simply to help
you visualize the algorithm so that you can watch exactly how the turtle
explores its way through the maze. Next the algorithm checks for the
first three of the four base cases: Has the turtle run into a wall (line
5)? Has the turtle circled back to a square already explored (line 8)?
Has the turtle found an exit (line 11)? If none of these conditions is
true then we continue the search recursively.</p>
<p>You will notice that in the recursive step there are four recursive
calls to <tt class="docutils literal"><span class="pre">searchFrom</span></tt>. It is hard to predict how many of these
recursive calls will be used since they are all connected by <tt class="docutils literal"><span class="pre">or</span></tt>
statements. If the first call to <tt class="docutils literal"><span class="pre">searchFrom</span></tt> returns <tt class="docutils literal"><span class="pre">True</span></tt> then
none of the last three calls would be needed. You can interpret this as
meaning that a step to <tt class="docutils literal"><span class="pre">(row-1,column)</span></tt> (or North if you want to think
geographically) is on the path leading out of the maze. If there is not
a good path leading out of the maze to the North then the next recursive
call is tried, this one to the South. If South fails then try West, and
finally East. If all four recursive calls return false then we have
found a dead end. You should download or type in the whole program and
experiment with it by changing the order of these calls.</p>
<p>The code for the <tt class="docutils literal"><span class="pre">Maze</span></tt> class is shown in <a class="reference internal" href="#lst-maze"><em>Listing 4</em></a>, <a class="reference internal" href="#lst-maze1"><em>Listing 5</em></a>, and <a class="reference internal" href="#lst-maze2"><em>Listing 6</em></a>.
The <tt class="docutils literal"><span class="pre">__init__</span></tt> method takes the name of a file as its
only parameter. This file is a text file that represents a maze by using
“+” characters for walls, spaces for open squares, and the letter “S” to
indicate the starting position. <a class="reference internal" href="#fig-exmaze"><em>Figure 4</em></a> is an example of a
maze data file. The internal representation of the maze is a list of
lists. Each row of the <tt class="docutils literal"><span class="pre">mazelist</span></tt> instance variable is also a list.
This secondary list contains one character per square using the
characters described above. For the data file in <a class="reference internal" href="#fig-exmaze"><em>Figure 4</em></a> the
internal representation looks like the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="s">&#39;+&#39;</span><span class="p">]]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">drawMaze</span></tt> method uses this internal representation to draw the
initial view of the maze on the screen, see <a class="reference internal" href="#fig-mazescreen"><em>Figure 3</em></a>.</p>
<blockquote id="fig-exmaze">
<div><div class="highlight-python"><pre>++++++++++++++++++++++
+   +   ++ ++     +
+ +   +       +++ + ++
+ + +  ++  ++++   + ++
+++ ++++++    +++ +  +
+          ++  ++    +
+++++ ++++++   +++++ +
+     +   +++++++  + +
+ +++++++      S +   +
+                + +++
++++++++++++++++++ +++</pre>
</div>
<p>An Example Maze Data File</p>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">updatePosition</span></tt> method, as shown in <a class="reference internal" href="#lst-maze1"><em>Listing 5</em></a> uses the
same internal representation to see if the turtle has run into a wall.
It also updates the internal representation with a “.” or “-” to
indicate that the turtle has visited a particular square or if the
square is part of a dead end. In addition, the <tt class="docutils literal"><span class="pre">updatePosition</span></tt> method
uses two helper methods, <tt class="docutils literal"><span class="pre">moveTurtle</span></tt> and <tt class="docutils literal"><span class="pre">dropBreadCrumb</span></tt>, to
update the view on the screen.</p>
<p>Finally, the <tt class="docutils literal"><span class="pre">isExit</span></tt> method uses the current position of the turtle
to test for an exit condition. An exit condition is whenever the turtle
has navigated to the edge of the maze, either row zero or column zero,
or the far right column or the bottom row.</p>
<div class="highlight-python" id="lst-maze"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Maze</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mazeFileName</span><span class="p">):</span>
        <span class="n">rowsInMaze</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">columnsInMaze</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mazelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mazeFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">mazeFileName</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">rowsInMaze</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">mazeFile</span><span class="p">:</span>
            <span class="n">rowList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">rowList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">startRow</span> <span class="o">=</span> <span class="n">rowsInMaze</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">startCol</span> <span class="o">=</span> <span class="n">col</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">rowsInMaze</span> <span class="o">=</span> <span class="n">rowsInMaze</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mazelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowList</span><span class="p">)</span>
            <span class="n">columnsInMaze</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rowsInMaze</span> <span class="o">=</span> <span class="n">rowsInMaze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columnsInMaze</span> <span class="o">=</span> <span class="n">columnsInMaze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xTranslate</span> <span class="o">=</span> <span class="o">-</span><span class="n">columnsInMaze</span><span class="o">/</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yTranslate</span> <span class="o">=</span> <span class="n">rowsInMaze</span><span class="o">/</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">Turtle</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s">&#39;turtle&#39;</span><span class="p">)</span>
        <span class="n">setup</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span><span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>
        <span class="n">setworldcoordinates</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">columnsInMaze</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span>
                            <span class="o">-</span><span class="p">(</span><span class="n">rowsInMaze</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">columnsInMaze</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+.</span><span class="mi">5</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">rowsInMaze</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+.</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python" id="lst-maze1"><div class="highlight"><pre><span class="k">def</span> <span class="nf">drawMaze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rowsInMaze</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columnsInMaze</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mazelist</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">OBSTACLE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">drawCenteredBox</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xTranslate</span><span class="p">,</span>
                                     <span class="o">-</span><span class="n">y</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">yTranslate</span><span class="p">,</span>
                                     <span class="s">&#39;tan&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">,</span><span class="s">&#39;blue&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">drawCenteredBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">color</span><span class="p">):</span>
    <span class="n">tracer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">up</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="n">x</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="n">y</span><span class="o">-.</span><span class="mi">5</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">,</span><span class="n">color</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">setheading</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">down</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">begin_fill</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">end_fill</span><span class="p">()</span>
    <span class="n">update</span><span class="p">()</span>
    <span class="n">tracer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">moveTurtle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">up</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">setheading</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">towards</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xTranslate</span><span class="p">,</span>
                                     <span class="o">-</span><span class="n">y</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">yTranslate</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xTranslate</span><span class="p">,</span><span class="o">-</span><span class="n">y</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">yTranslate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dropBreadcrumb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">color</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">updatePosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mazelist</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">moveTurtle</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="n">row</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">PART_OF_PATH</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s">&#39;green&#39;</span>
    <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="n">OBSTACLE</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s">&#39;red&#39;</span>
    <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="n">TRIED</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s">&#39;black&#39;</span>
    <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="n">DEAD_END</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s">&#39;red&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropBreadcrumb</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python" id="lst-maze2"><pre> def isExit(self,row,col):
     return (row == 0 or
             row == self.rowsInMaze-1 or
             col == 0 or
             col == self.columnsInMaze-1 )

def __getitem__(self,idx):
     return self.mazelist[idx]</pre>
</div>
<p>The complete program is given below as an activecode example.  This program uses the data file <tt class="docutils literal"><span class="pre">maze2.txt</span></tt> shown below.
Note that it is a much more simple example file in that the exit is very close to the starting position of the turtle.</p>
      <pre id="maze2.txt">
++++++++++++++++++++++
+   +   ++ ++        +
      +     ++++++++++
+ +    ++  ++++ +++ ++
+ +   + + ++    +++  +
+          ++  ++  + +
+++++ + +      ++  + +
+++++ +++  + +  ++   +
+          + + S+ +  +
+++++ +  + + +     + +
++++++++++++++++++++++
  </pre>
<div id="completemaze" >
<textarea cols="50" rows="12" id="completemaze_code" class="active_code">
import turtle

PART_OF_PATH = 'O'
TRIED = '.'
OBSTACLE = '+'
DEAD_END = '-'

class Maze:
    def __init__(self,mazeFileName):
        rowsInMaze = 0
        columnsInMaze = 0
        self.mazelist = []
        mazeFile = open(mazeFileName,'r')
        rowsInMaze = 0
        for line in mazeFile:
            rowList = []
            col = 0
            for ch in line[:-1]:
                rowList.append(ch)
                if ch == 'S':
                    self.startRow = rowsInMaze
                    self.startCol = col
                col = col + 1
            rowsInMaze = rowsInMaze + 1
            self.mazelist.append(rowList)
            columnsInMaze = len(rowList)

        self.rowsInMaze = rowsInMaze
        self.columnsInMaze = columnsInMaze
        self.xTranslate = -columnsInMaze/2
        self.yTranslate = rowsInMaze/2
        self.t = turtle.Turtle()
        self.t.shape('turtle')
        self.wn = turtle.Screen()
        self.wn.setworldcoordinates(-(columnsInMaze-1)/2-.5,-(rowsInMaze-1)/2-.5,(columnsInMaze-1)/2+.5,(rowsInMaze-1)/2+.5)

    def drawMaze(self):
        self.t.speed(10)
        for y in range(self.rowsInMaze):
            for x in range(self.columnsInMaze):
                if self.mazelist[y][x] == OBSTACLE:
                    self.drawCenteredBox(x+self.xTranslate,-y+self.yTranslate,'orange')
        self.t.color('black')
        self.t.fillcolor('blue')

    def drawCenteredBox(self,x,y,color):
        self.t.up()
        self.t.goto(x-.5,y-.5)
        self.t.color(color)
        self.t.fillcolor(color)
        self.t.setheading(90)
        self.t.down()
        self.t.begin_fill()
        for i in range(4):
            self.t.forward(1)
            self.t.right(90)
        self.t.end_fill()

    def moveTurtle(self,x,y):
        self.t.up()
        self.t.setheading(self.t.towards(x+self.xTranslate,-y+self.yTranslate))
        self.t.goto(x+self.xTranslate,-y+self.yTranslate)

    def dropBreadcrumb(self,color):
        self.t.dot(10,color)

    def updatePosition(self,row,col,val=None):
        if val:
            self.mazelist[row][col] = val
        self.moveTurtle(col,row)

        if val == PART_OF_PATH:
            color = 'green'
        elif val == OBSTACLE:
            color = 'red'
        elif val == TRIED:
            color = 'black'
        elif val == DEAD_END:
            color = 'red'
        else:
            color = None

        if color:
            self.dropBreadcrumb(color)

    def isExit(self,row,col):
        return (row == 0 or
                row == self.rowsInMaze-1 or
                col == 0 or
                col == self.columnsInMaze-1 )

    def __getitem__(self,idx):
        return self.mazelist[idx]


def searchFrom(maze, startRow, startColumn):
    # try each of four directions from this point until we find a way out.
    # base Case return values:
    #  1. We have run into an obstacle, return false
    maze.updatePosition(startRow, startColumn)
    if maze[startRow][startColumn] == OBSTACLE :
        return False
    #  2. We have found a square that has already been explored
    if maze[startRow][startColumn] == TRIED or maze[startRow][startColumn] == DEAD_END:
        return False
    # 3. We have found an outside edge not occupied by an obstacle
    if maze.isExit(startRow,startColumn):
        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
        return True
    maze.updatePosition(startRow, startColumn, TRIED)
    # Otherwise, use logical short circuiting to try each direction
    # in turn (if needed)
    found = searchFrom(maze, startRow-1, startColumn) or \
            searchFrom(maze, startRow+1, startColumn) or \
            searchFrom(maze, startRow, startColumn-1) or \
            searchFrom(maze, startRow, startColumn+1)
    if found:
        maze.updatePosition(startRow, startColumn, PART_OF_PATH)
    else:
        maze.updatePosition(startRow, startColumn, DEAD_END)
    return found


myMaze = Maze('maze2.txt')
myMaze.drawMaze()
myMaze.updatePosition(myMaze.startRow,myMaze.startCol)

searchFrom(myMaze, myMaze.startRow, myMaze.startCol)

</textarea>
<p class="ac_caption"><span class="ac_caption_text"> (completemaze)</span> </p>
<button onclick="runit('completemaze',this, undefined);">Run</button>
<button class="ac_opt" onclick="saveEditor('completemaze');">Save</button>
<button class="ac_opt" onclick="requestCode('completemaze');">Load</button>
<br />

<canvas id="completemaze_canvas" height="400" width="400" style="border-style: solid; display: none"></canvas>

<pre id="completemaze_pre" class="active_out">

</pre>

</div>

</div>
<div class="section" id="dynamic-programming">
<h1>Dynamic Programming<a class="headerlink" href="#dynamic-programming" title="Permalink to this headline">¶</a></h1>
<p>Many programs in computer science are written to optimize some value;
for example, find the shortest path between two points, find the line
that best fits a set of points, or find the smallest set of objects that
satisfies some criteria. There are many strategies that computer
scientists use to solve these problems. One of the goals of this book is
to expose you to several different problem solving strategies. <strong>Dynamic
programming</strong> is one strategy for these types of optimization problems.</p>
<p>A classic example of an optimization problem involves making change
using the fewest coins. Suppose you are a programmer for a vending
machine manufacturer. Your company wants to streamline effort by giving
out the fewest possible coins in change for each transaction. Suppose a
customer puts in a dollar bill and purchases an item for 37 cents. What
is the smallest number of coins you can use to make change? The answer
is six coins: two quarters, one dime, and three pennies. How did we
arrive at the answer of six coins? We start with the largest coin in our
arsenal (a quarter) and use as many of those as possible, then we go to
the next lowest coin value and use as many of those as possible. This
first approach is called a <strong>greedy method</strong> because we try to solve as
big a piece of the problem as possible right away.</p>
<p>The greedy method works fine when we are using U.S. coins, but suppose
that your company decides to deploy its vending machines in Lower
Elbonia where, in addition to the usual 1, 5, 10, and 25 cent coins they
also have a 21 cent coin. In this instance our greedy method fails to
find the optimal solution for 63 cents in change. With the addition of
the 21 cent coin the greedy method would still find the solution to be
six coins. However, the optimal answer is three 21 cent pieces.</p>
<p>Let’s look at a method where we could be sure that we would find the
optimal answer to the problem. Since this section is about recursion,
you may have guessed that we will use a recursive solution. Let’s start
with identifying the base case. If we are trying to make change for the
same amount as the value of one of our coins, the answer is easy, one
coin.</p>
<p>If the amount does not match we have several options. What we want is
the minimum of a penny plus the number of coins needed to make change
for the original amount minus a penny, or a nickel plus the number of
coins needed to make change for the original amount minus five cents, or
a dime plus the number of coins needed to make change for the original
amount minus ten cents, and so on. So the number of coins needed to make
change for the original amount can be computed according to the
following:</p>
<div class="math">
\[\begin{split}   numCoins =
min
\begin{cases}
1 + numCoins(original amount - 1) \\
1 + numCoins(original amount - 5) \\
1 + numCoins(original amount - 10) \\
1 + numCoins(original amount - 25)
\end{cases}
\label{eqn_change}\end{split}\]</div>
<p>The algorithm for doing what we have just described is shown in
<a class="reference internal" href="#lst-change1"><em>Listing 7</em></a>. In line&nbsp;3 we are checking our base case;
that is, we are trying to make change in the exact amount of one of our
coins. If we do not have a coin equal to the amount of change, we make
recursive calls for each different coin value less than the amount of
change we are trying to make. Line&nbsp;6 shows how we filter the
list of coins to those less than the current value of change using a
list comprehension. The recursive call also reduces the total amount of
change we need to make by the value of the coin selected. The recursive
call is made in line&nbsp;7. Notice that on that same line we add 1
to our number of coins to account for the fact that we are using a coin.
Just adding 1 is the same as if we had made a recursive call asking
where we satisfy the base case condition immediately.</p>
<div class="highlight-python" id="lst-change1"><div class="highlight"><pre><span class="k">def</span> <span class="nf">recMC</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span><span class="n">change</span><span class="p">):</span>
   <span class="n">minCoins</span> <span class="o">=</span> <span class="n">change</span>
   <span class="k">if</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">coinValueList</span><span class="p">:</span>
     <span class="k">return</span> <span class="mi">1</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coinValueList</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">change</span><span class="p">]:</span>
         <span class="n">numCoins</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">recMC</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span><span class="n">change</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">numCoins</span> <span class="o">&lt;</span> <span class="n">minCoins</span><span class="p">:</span>
            <span class="n">minCoins</span> <span class="o">=</span> <span class="n">numCoins</span>
   <span class="k">return</span> <span class="n">minCoins</span>

<span class="k">print</span><span class="p">(</span><span class="n">recMC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">25</span><span class="p">],</span><span class="mi">63</span><span class="p">))</span>
</pre></div>
</div>
<p>The trouble with the algorithm in <a class="reference internal" href="#lst-change1"><em>Listing 7</em></a> is that it is
extremely inefficient. In fact, it takes 67,716,925 recursive calls to
find the optimal solution to the 4 coins, 63 cents problem! To
understand the fatal flaw in our approach look at <a class="reference internal" href="#fig-c1ct"><em>Figure 5</em></a>,
which illustrates a small fraction of the 377 function calls needed to
find the optimal set of coins to make change for 26 cents.</p>
<p>Each node in the graph corresponds to a call to <tt class="docutils literal"><span class="pre">recMC</span></tt>. The label on
the node indicates the amount of change for which we are computing the
number of coins. The label on the arrow indicates the coin that we just
used. By following the graph we can see the combination of coins that
got us to any point in the graph. The main problem is that we are
re-doing too many calculations. For example, the graph shows that the
algorithm would recalculate the optimal number of coins to make change
for 15 cents at least three times. Each of these computations to find
the optimal number of coins for 15 cents itself takes 52 function calls.
Clearly we are wasting a lot of time and effort recalculating old
results.</p>
<blockquote id="fig-c1ct">
<div><div class="figure align-center">
<img alt="image" src="../_images/callTree.png" style="width: 100%;" />
<p class="caption">Call Tree for Listing 7</p>
</div>
</div></blockquote>
<p>The key to cutting down on the amount of work we do is to remember some
of the past results so we can avoid recomputing results we already know.
A simple solution is to store the results for the minimum number of
coins in a table when we find them. Then before we compute a new
minimum, we first check the table to see if a result is already known.
If there is already a result in the table, we use the value from the
table rather than recomputing. <a class="reference internal" href="#lst-change2"><em>Listing 8</em></a> shows a modified
algorithm to incorporate our table lookup scheme.</p>

<div id="lst_change2" >
<textarea cols="50" rows="12" id="lst_change2_code" class="active_code">
def recDC(coinValueList,change,knownResults):
   minCoins = change
   if change in coinValueList:
      knownResults[change] = 1
      return 1
   elif knownResults[change] > 0:
      return knownResults[change]
   else:
       for i in [c for c in coinValueList if c <= change]:
         numCoins = 1 + recDC(coinValueList, change-i,
                              knownResults)
         if numCoins < minCoins:
            minCoins = numCoins
            knownResults[change] = minCoins
   return minCoins

print(recDC([1,5,10,25],63,[0]*64))

</textarea>
<p class="ac_caption"><span class="ac_caption_text"> (lst_change2)</span> </p>
<button onclick="runit('lst_change2',this, undefined);">Run</button>
<button class="ac_opt" onclick="saveEditor('lst_change2');">Save</button>
<button class="ac_opt" onclick="requestCode('lst_change2');">Load</button>
<br />

<canvas id="lst_change2_canvas" height="400" width="400" style="border-style: solid; display: none"></canvas>

<pre id="lst_change2_pre" class="active_out">

</pre>

</div>

<p>Notice that in line&nbsp;6 we have added a test to see if our table
contains the minimum number of coins for a certain amount of change. If
it does not, we compute the minimum recursively and store the computed
minimum in the table. Using this modified algorithm reduces the number
of recursive calls we need to make for the four coin, 63 cent problem to
221 calls!</p>
<p>Although the algorithm in <a class="reference internal" href="#lst-change2"><em>Listing 8</em></a> is correct, it looks and
feels like a bit of a hack.  Also, if we look at the <tt class="docutils literal"><span class="pre">knownResults</span></tt> lists
we can see that there are some holes in the table. In fact the term for
what we have done is not dynamic programming but rather we have improved
the performance of our program by using a technique known as
“memoization,” or more commonly called “caching.”</p>
<p>A truly dynamic programming algorithm will take a more systematic
approach to the problem. Our dynamic programming solution is going to
start with making change for one cent and systematically work its way up
to the amount of change we require. This guarantees us that at each step
of the algorithm we already know the minimum number of coins needed to
make change for any smaller amount.</p>
<p>Let’s look at how we would fill in a table of minimum coins to use in
making change for 11 cents. <a class="reference internal" href="#fig-dpcoins"><em>Figure 6</em></a> illustrates the
process. We start with one cent. The only solution possible is one coin
(a penny). The next row shows the minimum for one cent and two cents.
Again, the only solution is two pennies. The fifth row is where things
get interesting. Now we have two options to consider, five pennies or
one nickel. How do we decide which is best? We consult the table and see
that the number of coins needed to make change for four cents is four,
plus one more penny to make five, equals five coins. Or we can look at
zero cents plus one more nickel to make five cents equals 1 coin. Since
the minimum of one and five is one we store 1 in the table. Fast forward
again to the end of the table and consider 11 cents. <a class="reference internal" href="#fig-eleven"><em>Figure 7</em></a>
shows the three options that we have to consider:</p>
<ol class="arabic simple">
<li>A penny plus the minimum number of coins to make change for
<span class="math">\(11-1 = 10\)</span> cents (1)</li>
<li>A nickel plus the minimum number of coins to make change for
<span class="math">\(11 - 5 = 6\)</span> cents (2)</li>
<li>A dime plus the minimum number of coins to make change for
<span class="math">\(11 - 10 = 1\)</span> cent (1)</li>
</ol>
<p>Either option 1 or 3 will give us a total of two coins which is the
minimum number of coins for 11 cents.</p>
<div class="figure align-center" id="fig-dpcoins">
<img alt="image" src="../_images/changeTable.png" />
<p class="caption">Minimum Number of Coins Needed to Make Change</p>
</div>
<div class="figure align-center" id="fig-eleven">
<img alt="image" src="../_images/elevenCents.png" />
<p class="caption">Three Options to Consider for the Minimum Number of Coins for Eleven Cents</p>
</div>
<p><a class="reference internal" href="#lst-dpchange"><em>Listing 9</em></a> is a dynamic programming algorithm to solve our
change-making problem. <tt class="docutils literal"><span class="pre">dpMakeChange</span></tt> takes three parameters: a list
of valid coin values, the amount of change we want to make, and a list
of the minimum number of coins needed to make each value. When the
function is done <tt class="docutils literal"><span class="pre">minCoins</span></tt> will contain the solution for all values
from 0 to the value of <tt class="docutils literal"><span class="pre">change</span></tt>.</p>
<div class="highlight-python" id="lst-dpchange"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dpMakeChange</span><span class="p">(</span><span class="n">coinValueList</span><span class="p">,</span><span class="n">change</span><span class="p">,</span><span class="n">minCoins</span><span class="p">):</span>
   <span class="k">for</span> <span class="n">cents</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">change</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
      <span class="n">coinCount</span> <span class="o">=</span> <span class="n">cents</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coinValueList</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">cents</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">minCoins</span><span class="p">[</span><span class="n">cents</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">coinCount</span><span class="p">:</span>
               <span class="n">coinCount</span> <span class="o">=</span> <span class="n">minCoins</span><span class="p">[</span><span class="n">cents</span><span class="o">-</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
      <span class="n">minCoins</span><span class="p">[</span><span class="n">cents</span><span class="p">]</span> <span class="o">=</span> <span class="n">coinCount</span>
   <span class="k">return</span> <span class="n">minCoins</span><span class="p">[</span><span class="n">change</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">dpMakeChange</span></tt> is not a recursive function, even though we
started with a recursive solution to this problem. It is important to
realize that just because you can write a recursive solution to a
problem does not mean it is the best or most efficient solution. The
bulk of the work in this function is done by the loop that starts on
line&nbsp;4. In this loop we consider using all possible coins to
make change for the amount specified by <tt class="docutils literal"><span class="pre">cents</span></tt>. Like we did for the
11 cent example above, we remember the minimum value and store it in our
<tt class="docutils literal"><span class="pre">minCoins</span></tt> list.</p>
<p>Although our making change algorithm does a good job of figuring out the
minimum number of coins, it does not help us make change since we do not
keep track of the coins we use. We can easily extend <tt class="docutils literal"><span class="pre">dpMakeChange</span></tt> to
keep track of the coins used by simply remembering the last coin we add
for each entry in the <tt class="docutils literal"><span class="pre">minCoins</span></tt> table. If we know the last coin
added, we can simply subtract the value of the coin to find a previous
entry in the table that tells us the last coin we added to make that
amount. We can keep tracing back through the table until we get to the
beginning.</p>
<p><a class="reference internal" href="#lst-dpremember"><em>Listing 10</em></a> shows the <tt class="docutils literal"><span class="pre">dpMakeChange</span></tt> algorithm
modified to keep track of the coins used, along with a function
<tt class="docutils literal"><span class="pre">printCoins</span></tt> that walks backward through the table to print out the
value of each coin used.
This shows the algorithm in
action solving the problem for our friends in Lower Elbonia. The first
two lines of <tt class="docutils literal"><span class="pre">main</span></tt> set the amount to be converted and create the list of coins used. The next two
lines create the lists we need to store the results. <tt class="docutils literal"><span class="pre">coinsUsed</span></tt> is a
list of the coins used to make change, and <tt class="docutils literal"><span class="pre">coinCount</span></tt> is the minimum
number of coins used to make change for the amount corresponding to the
position in the list.</p>
<p>Notice that the coins we print out come directly from the <tt class="docutils literal"><span class="pre">coinsUsed</span></tt>
array. For the first call we start at array position 63 and print 21.
Then we take <span class="math">\(63 - 21 = 42\)</span> and look at the 42nd element of the
list. Once again we find a 21 stored there. Finally, element 21 of the
array also contains 21, giving us the three 21 cent pieces.</p>

<div id="lst_dpremember" >
<textarea cols="50" rows="12" id="lst_dpremember_code" class="active_code">
def dpMakeChange(coinValueList,change,minCoins,coinsUsed):
   for cents in range(change+1):
      coinCount = cents
      newCoin = 1
      for j in [c for c in coinValueList if c <= cents]:
            if minCoins[cents-j] + 1 < coinCount:
               coinCount = minCoins[cents-j]+1
               newCoin = j
      minCoins[cents] = coinCount
      coinsUsed[cents] = newCoin
   return minCoins[change]

def printCoins(coinsUsed,change):
   coin = change
   while coin > 0:
      thisCoin = coinsUsed[coin]
      print(thisCoin)
      coin = coin - thisCoin

def main():
    amnt = 63
    clist = [1,5,10,21,25]
    coinsUsed = [0]*(amnt+1)
    coinCount = [0]*(amnt+1)

    print("Making change for",amnt,"requires")
    print(dpMakeChange(clist,amnt,coinCount,coinsUsed),"coins")
    print("They are:")
    printCoins(coinsUsed,amnt)
    print("The used list is as follows:")
    print(coinsUsed)

main()

</textarea>
<p class="ac_caption"><span class="ac_caption_text"> (lst_dpremember)</span> </p>
<button onclick="runit('lst_dpremember',this, undefined);">Run</button>
<button class="ac_opt" onclick="saveEditor('lst_dpremember');">Save</button>
<button class="ac_opt" onclick="requestCode('lst_dpremember');">Load</button>
<br />

<canvas id="lst_dpremember_canvas" height="400" width="400" style="border-style: solid; display: none"></canvas>

<pre id="lst_dpremember_pre" class="active_out">

</pre>

</div>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">How to Think Like a Computer Scientist</a> &raquo;</li>
<li class="right"><span class="loginout"><a href="/courselib/default/user/logout">logout</a></span>| </li>

      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2012, Brad Miller, David Ranum.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-32029811-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>